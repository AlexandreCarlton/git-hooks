#!/bin/sh

# Extracts the JIRA ticket identifier from the branch and substitutes it into
# a special expression in the message template if present.
# The syntax is:
#   {{.*TICKET.*}}
# where characters before and after 'TICKET' are preserved.
# For example, {{[TICKET] }} for ISSUE-123 would translate to '[ISSUE-123] '.
# If no ticket can be extracted, the expressions are removed.

FILEPATH="${1}"

# Returns empty string on failure
get_ticket_from_branch() {
  local branch="${1}"
  local branch_pattern='^([[:lower:]]{1,30}/)?([[:upper:]]{2,}-[[:digit:]]+)(-[[:alnum:]]+)+$'
  local ticket_dest='\2'
  printf '%s' "${branch}" |\
    sed --regexp-extended --quiet "s:${branch_pattern}:${ticket_dest}:p"
}


insert_ticket() {
  local filepath="${1}"
  local branch
  local ticket
  local last_line_number
  local pattern="\\{\\{(.*)TICKET(.*)\\}\\}"

  branch="$(git symbolic-ref --short HEAD)"
  ticket="$(get_ticket_from_branch "${branch}")"
  last_line_number="$(get_commit_message_length "${filepath}")"

  if [ -n "${ticket}" ]; then
    sed --regexp-extended --in-place "1,${last_line_number}s/${pattern}/\\1${ticket}\\2/" "${filepath}"
  else
    sed --regexp-extended --in-place "1,${last_line_number}s/${pattern}//" "${filepath}"
  fi
}

get_commit_message_length() {
  local filepath="${1}"
  local match
  match=$(grep \
    --extended-regexp \
    --line-number \
    '^# -+ >8' \
    "${filepath}" \
    | cut \
      --delimiter=':' \
      --fields=1)
  if [ -n "${match}" ]; then
    printf '%s\n' "${match}"
  else
    printf 'Could not find scissor (--->8---) - please inspect message.\n' >&2
    wc --lines "${filepath}" \
      | awk '{ print $1 }'
  fi
}

insert_ticket "${FILEPATH}"
