#!/bin/sh

# Extracts the JIRA ticket identifier from the branch and substitutes it into
# a special expression in the message template if present.
# The syntax is:
#   {{.*TICKET.*}}
# where characters before and after 'TICKET' are preserved.
# For example, {{[TICKET] }} for ISSUE-123 would translate to '[ISSUE-123] '.
# If no ticket can be extracted, the expressions are removed.

FILEPATH="${1}"

# Returns empty string on failure
get_ticket_from_branch() {
  local branch="${1}"
  local branch_pattern='^([[:lower:]]{1,30}/)?([[:upper:]]{2,}-[[:digit:]]+)(-[[:alnum:]]+)+$'
  local ticket_dest='\2'
  printf '%s' "${branch}" |\
    sed --regexp-extended --quiet "s:${branch_pattern}:${ticket_dest}:p"
}


insert_ticket() {
  local filepath="${1}"
  local branch
  local ticket
  local last_line_number
  local pattern="\\{\\{(.*)TICKET(.*)\\}\\}"

  branch="$(git symbolic-ref --short HEAD)"
  ticket="$(get_ticket_from_branch "${branch}")"
  last_line_number="$(get_commit_message_length "${filepath}")"

  if [ -n "${ticket}" ]; then
    sed --regexp-extended --in-place "1,${last_line_number}s/${pattern}/\\1${ticket}\\2/" "${filepath}"
  else
    sed --regexp-extended --in-place "1,${last_line_number}s/${pattern}//" "${filepath}"
  fi
}

# We don't want to edit the patch itself, so we restrict ourselves to editing
# the commit message.
get_commit_message_length() {
  local filepath="${1}"
  grep \
    --fixed-strings \
    --line-number \
    '^# Please enter the commit message for your changes.' \
    "${filepath}" \
    | cut \
      --delimiter=':' \
      --fields=1
}

insert_ticket "${FILEPATH}"
